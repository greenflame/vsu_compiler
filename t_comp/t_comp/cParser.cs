//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.2 c.g 2015-10-19 16:31:29

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  t_comp 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.2")]
[System.CLSCompliant(false)]
public partial class cParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "ASSIGN", "BLOCK", "DIV", "ELSE", "EQUALS", "FOR", "FUNCCALL", "GE", "GT", "ID", "IF", "LADD", "LE", "LMUL", "LOGIC", "LT", "ML_COMMENT", "MUL", "NEQUALS", "NUMBER", "PARAMS", "PROGRAM", "READ", "SL_COMMENT", "STRING", "SUB", "WRITE", "WS", "'('", "')'", "','", "';'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__33=33;
	public const int T__34=34;
	public const int T__35=35;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int ADD=4;
	public const int ASSIGN=5;
	public const int BLOCK=6;
	public const int DIV=7;
	public const int ELSE=8;
	public const int EQUALS=9;
	public const int FOR=10;
	public const int FUNCCALL=11;
	public const int GE=12;
	public const int GT=13;
	public const int ID=14;
	public const int IF=15;
	public const int LADD=16;
	public const int LE=17;
	public const int LMUL=18;
	public const int LOGIC=19;
	public const int LT=20;
	public const int ML_COMMENT=21;
	public const int MUL=22;
	public const int NEQUALS=23;
	public const int NUMBER=24;
	public const int PARAMS=25;
	public const int PROGRAM=26;
	public const int READ=27;
	public const int SL_COMMENT=28;
	public const int STRING=29;
	public const int SUB=30;
	public const int WRITE=31;
	public const int WS=32;

	public cParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public cParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return cParser.tokenNames; } }
	public override string GrammarFileName { get { return "c.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_primitive_value();
	partial void LeaveRule_primitive_value();
	// $ANTLR start "primitive_value"
	// c.g:83:1: primitive_value : ( NUMBER | STRING | LOGIC | ID | func_call );
	[GrammarRule("primitive_value")]
	private AstParserRuleReturnScope<object, IToken> primitive_value()
	{
		EnterRule_primitive_value();
		EnterRule("primitive_value", 1);
		TraceIn("primitive_value", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUMBER1 = default(IToken);
		IToken STRING2 = default(IToken);
		IToken LOGIC3 = default(IToken);
		IToken ID4 = default(IToken);
		AstParserRuleReturnScope<object, IToken> func_call5 = default(AstParserRuleReturnScope<object, IToken>);

		object NUMBER1_tree = default(object);
		object STRING2_tree = default(object);
		object LOGIC3_tree = default(object);
		object ID4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "primitive_value");
		DebugLocation(83, 1);
		try
		{
			// c.g:84:2: ( NUMBER | STRING | LOGIC | ID | func_call )
			int alt1=5;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case NUMBER:
				{
				alt1 = 1;
				}
				break;
			case STRING:
				{
				alt1 = 2;
				}
				break;
			case LOGIC:
				{
				alt1 = 3;
				}
				break;
			case ID:
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2==33))
				{
					alt1 = 5;
				}
				else if ((LA1_2==ADD||LA1_2==DIV||LA1_2==EQUALS||(LA1_2>=GE && LA1_2<=GT)||(LA1_2>=LADD && LA1_2<=LMUL)||LA1_2==LT||(LA1_2>=MUL && LA1_2<=NEQUALS)||LA1_2==SUB||(LA1_2>=34 && LA1_2<=36)))
				{
					alt1 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// c.g:84:4: NUMBER
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(84, 4);
				NUMBER1=(IToken)Match(input,NUMBER,Follow._NUMBER_in_primitive_value450); 
				NUMBER1_tree = (object)adaptor.Create(NUMBER1);
				adaptor.AddChild(root_0, NUMBER1_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// c.g:85:4: STRING
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(85, 4);
				STRING2=(IToken)Match(input,STRING,Follow._STRING_in_primitive_value455); 
				STRING2_tree = (object)adaptor.Create(STRING2);
				adaptor.AddChild(root_0, STRING2_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// c.g:86:4: LOGIC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(86, 4);
				LOGIC3=(IToken)Match(input,LOGIC,Follow._LOGIC_in_primitive_value460); 
				LOGIC3_tree = (object)adaptor.Create(LOGIC3);
				adaptor.AddChild(root_0, LOGIC3_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// c.g:87:4: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(87, 4);
				ID4=(IToken)Match(input,ID,Follow._ID_in_primitive_value465); 
				ID4_tree = (object)adaptor.Create(ID4);
				adaptor.AddChild(root_0, ID4_tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// c.g:88:4: func_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._func_call_in_primitive_value470);
				func_call5=func_call();
				PopFollow();

				adaptor.AddChild(root_0, func_call5.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primitive_value", 1);
			LeaveRule("primitive_value", 1);
			LeaveRule_primitive_value();
		}
		DebugLocation(89, 1);
		} finally { DebugExitRule(GrammarFileName, "primitive_value"); }
		return retval;

	}
	// $ANTLR end "primitive_value"

	partial void EnterRule_value_group();
	partial void LeaveRule_value_group();
	// $ANTLR start "value_group"
	// c.g:91:1: value_group : ( '(' ! value_add ')' !| primitive_value );
	[GrammarRule("value_group")]
	private AstParserRuleReturnScope<object, IToken> value_group()
	{
		EnterRule_value_group();
		EnterRule("value_group", 2);
		TraceIn("value_group", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal6 = default(IToken);
		IToken char_literal8 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_add7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primitive_value9 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal6_tree = default(object);
		object char_literal8_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_group");
		DebugLocation(91, 1);
		try
		{
			// c.g:92:2: ( '(' ! value_add ')' !| primitive_value )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==33))
			{
				alt2 = 1;
			}
			else if ((LA2_1==ID||LA2_1==LOGIC||LA2_1==NUMBER||LA2_1==STRING))
			{
				alt2 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// c.g:92:4: '(' ! value_add ')' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(92, 7);
				char_literal6=(IToken)Match(input,33,Follow._33_in_value_group481); 
				DebugLocation(92, 9);
				PushFollow(Follow._value_add_in_value_group484);
				value_add7=value_add();
				PopFollow();

				adaptor.AddChild(root_0, value_add7.Tree);
				DebugLocation(92, 22);
				char_literal8=(IToken)Match(input,34,Follow._34_in_value_group486); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// c.g:92:26: primitive_value
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(92, 26);
				PushFollow(Follow._primitive_value_in_value_group491);
				primitive_value9=primitive_value();
				PopFollow();

				adaptor.AddChild(root_0, primitive_value9.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_group", 2);
			LeaveRule("value_group", 2);
			LeaveRule_value_group();
		}
		DebugLocation(93, 1);
		} finally { DebugExitRule(GrammarFileName, "value_group"); }
		return retval;

	}
	// $ANTLR end "value_group"

	partial void EnterRule_value_mult();
	partial void LeaveRule_value_mult();
	// $ANTLR start "value_mult"
	// c.g:95:1: value_mult : value_group ( ( MUL | DIV ) ^ value_group )* ;
	[GrammarRule("value_mult")]
	private AstParserRuleReturnScope<object, IToken> value_mult()
	{
		EnterRule_value_mult();
		EnterRule("value_mult", 3);
		TraceIn("value_mult", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set11 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_group10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_group12 = default(AstParserRuleReturnScope<object, IToken>);

		object set11_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_mult");
		DebugLocation(95, 1);
		try
		{
			// c.g:96:2: ( value_group ( ( MUL | DIV ) ^ value_group )* )
			DebugEnterAlt(1);
			// c.g:96:4: value_group ( ( MUL | DIV ) ^ value_group )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(96, 4);
			PushFollow(Follow._value_group_in_value_mult503);
			value_group10=value_group();
			PopFollow();

			adaptor.AddChild(root_0, value_group10.Tree);
			DebugLocation(96, 16);
			// c.g:96:16: ( ( MUL | DIV ) ^ value_group )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==DIV||LA3_1==MUL))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// c.g:96:18: ( MUL | DIV ) ^ value_group
					{
					DebugLocation(96, 31);

					set11=(IToken)input.LT(1);
					set11=(IToken)input.LT(1);
					if (input.LA(1)==DIV||input.LA(1)==MUL)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set11), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(96, 33);
					PushFollow(Follow._value_group_in_value_mult518);
					value_group12=value_group();
					PopFollow();

					adaptor.AddChild(root_0, value_group12.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_mult", 3);
			LeaveRule("value_mult", 3);
			LeaveRule_value_mult();
		}
		DebugLocation(97, 1);
		} finally { DebugExitRule(GrammarFileName, "value_mult"); }
		return retval;

	}
	// $ANTLR end "value_mult"

	partial void EnterRule_value_add();
	partial void LeaveRule_value_add();
	// $ANTLR start "value_add"
	// c.g:99:1: value_add : value_mult ( ( ADD | SUB ) ^ value_mult )* ;
	[GrammarRule("value_add")]
	private AstParserRuleReturnScope<object, IToken> value_add()
	{
		EnterRule_value_add();
		EnterRule("value_add", 4);
		TraceIn("value_add", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set14 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_mult13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_mult15 = default(AstParserRuleReturnScope<object, IToken>);

		object set14_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_add");
		DebugLocation(99, 1);
		try
		{
			// c.g:100:2: ( value_mult ( ( ADD | SUB ) ^ value_mult )* )
			DebugEnterAlt(1);
			// c.g:100:4: value_mult ( ( ADD | SUB ) ^ value_mult )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(100, 4);
			PushFollow(Follow._value_mult_in_value_add533);
			value_mult13=value_mult();
			PopFollow();

			adaptor.AddChild(root_0, value_mult13.Tree);
			DebugLocation(100, 15);
			// c.g:100:15: ( ( ADD | SUB ) ^ value_mult )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==ADD||LA4_1==SUB))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// c.g:100:17: ( ADD | SUB ) ^ value_mult
					{
					DebugLocation(100, 30);

					set14=(IToken)input.LT(1);
					set14=(IToken)input.LT(1);
					if (input.LA(1)==ADD||input.LA(1)==SUB)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set14), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(100, 32);
					PushFollow(Follow._value_mult_in_value_add548);
					value_mult15=value_mult();
					PopFollow();

					adaptor.AddChild(root_0, value_mult15.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_add", 4);
			LeaveRule("value_add", 4);
			LeaveRule_value_add();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "value_add"); }
		return retval;

	}
	// $ANTLR end "value_add"

	partial void EnterRule_logic_group();
	partial void LeaveRule_logic_group();
	// $ANTLR start "logic_group"
	// c.g:104:1: logic_group : value_add ( ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add )? ;
	[GrammarRule("logic_group")]
	private AstParserRuleReturnScope<object, IToken> logic_group()
	{
		EnterRule_logic_group();
		EnterRule("logic_group", 5);
		TraceIn("logic_group", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set17 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_add16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_add18 = default(AstParserRuleReturnScope<object, IToken>);

		object set17_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logic_group");
		DebugLocation(104, 1);
		try
		{
			// c.g:105:2: ( value_add ( ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add )? )
			DebugEnterAlt(1);
			// c.g:105:4: value_add ( ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(105, 4);
			PushFollow(Follow._value_add_in_logic_group564);
			value_add16=value_add();
			PopFollow();

			adaptor.AddChild(root_0, value_add16.Tree);
			DebugLocation(105, 14);
			// c.g:105:14: ( ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==EQUALS||(LA5_1>=GE && LA5_1<=GT)||LA5_1==LE||LA5_1==LT||LA5_1==NEQUALS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// c.g:105:16: ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add
				{
				DebugLocation(105, 56);

				set17=(IToken)input.LT(1);
				set17=(IToken)input.LT(1);
				if (input.LA(1)==EQUALS||(input.LA(1)>=GE && input.LA(1)<=GT)||input.LA(1)==LE||input.LA(1)==LT||input.LA(1)==NEQUALS)
				{
					input.Consume();
					root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set17), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(105, 58);
				PushFollow(Follow._value_add_in_logic_group595);
				value_add18=value_add();
				PopFollow();

				adaptor.AddChild(root_0, value_add18.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logic_group", 5);
			LeaveRule("logic_group", 5);
			LeaveRule_logic_group();
		}
		DebugLocation(106, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_group"); }
		return retval;

	}
	// $ANTLR end "logic_group"

	partial void EnterRule_logic_mult();
	partial void LeaveRule_logic_mult();
	// $ANTLR start "logic_mult"
	// c.g:108:1: logic_mult : logic_group ( LMUL ^ logic_group )* ;
	[GrammarRule("logic_mult")]
	private AstParserRuleReturnScope<object, IToken> logic_mult()
	{
		EnterRule_logic_mult();
		EnterRule("logic_mult", 6);
		TraceIn("logic_mult", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LMUL20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_group19 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_group21 = default(AstParserRuleReturnScope<object, IToken>);

		object LMUL20_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logic_mult");
		DebugLocation(108, 1);
		try
		{
			// c.g:109:2: ( logic_group ( LMUL ^ logic_group )* )
			DebugEnterAlt(1);
			// c.g:109:4: logic_group ( LMUL ^ logic_group )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(109, 4);
			PushFollow(Follow._logic_group_in_logic_mult610);
			logic_group19=logic_group();
			PopFollow();

			adaptor.AddChild(root_0, logic_group19.Tree);
			DebugLocation(109, 16);
			// c.g:109:16: ( LMUL ^ logic_group )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==LMUL))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// c.g:109:18: LMUL ^ logic_group
					{
					DebugLocation(109, 22);
					LMUL20=(IToken)Match(input,LMUL,Follow._LMUL_in_logic_mult614); 
					LMUL20_tree = (object)adaptor.Create(LMUL20);
					root_0 = (object)adaptor.BecomeRoot(LMUL20_tree, root_0);
					DebugLocation(109, 24);
					PushFollow(Follow._logic_group_in_logic_mult617);
					logic_group21=logic_group();
					PopFollow();

					adaptor.AddChild(root_0, logic_group21.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logic_mult", 6);
			LeaveRule("logic_mult", 6);
			LeaveRule_logic_mult();
		}
		DebugLocation(110, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_mult"); }
		return retval;

	}
	// $ANTLR end "logic_mult"

	partial void EnterRule_logic_add();
	partial void LeaveRule_logic_add();
	// $ANTLR start "logic_add"
	// c.g:112:1: logic_add : logic_mult ( LADD ^ logic_mult )* ;
	[GrammarRule("logic_add")]
	private AstParserRuleReturnScope<object, IToken> logic_add()
	{
		EnterRule_logic_add();
		EnterRule("logic_add", 7);
		TraceIn("logic_add", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LADD23 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_mult22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_mult24 = default(AstParserRuleReturnScope<object, IToken>);

		object LADD23_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logic_add");
		DebugLocation(112, 1);
		try
		{
			// c.g:113:2: ( logic_mult ( LADD ^ logic_mult )* )
			DebugEnterAlt(1);
			// c.g:113:4: logic_mult ( LADD ^ logic_mult )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(113, 4);
			PushFollow(Follow._logic_mult_in_logic_add631);
			logic_mult22=logic_mult();
			PopFollow();

			adaptor.AddChild(root_0, logic_mult22.Tree);
			DebugLocation(113, 15);
			// c.g:113:15: ( LADD ^ logic_mult )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==LADD))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// c.g:113:17: LADD ^ logic_mult
					{
					DebugLocation(113, 21);
					LADD23=(IToken)Match(input,LADD,Follow._LADD_in_logic_add635); 
					LADD23_tree = (object)adaptor.Create(LADD23);
					root_0 = (object)adaptor.BecomeRoot(LADD23_tree, root_0);
					DebugLocation(113, 23);
					PushFollow(Follow._logic_mult_in_logic_add638);
					logic_mult24=logic_mult();
					PopFollow();

					adaptor.AddChild(root_0, logic_mult24.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logic_add", 7);
			LeaveRule("logic_add", 7);
			LeaveRule_logic_add();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_add"); }
		return retval;

	}
	// $ANTLR end "logic_add"

	partial void EnterRule_value_expr();
	partial void LeaveRule_value_expr();
	// $ANTLR start "value_expr"
	// c.g:116:1: value_expr : logic_add ;
	[GrammarRule("value_expr")]
	private AstParserRuleReturnScope<object, IToken> value_expr()
	{
		EnterRule_value_expr();
		EnterRule("value_expr", 8);
		TraceIn("value_expr", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> logic_add25 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "value_expr");
		DebugLocation(116, 1);
		try
		{
			// c.g:117:2: ( logic_add )
			DebugEnterAlt(1);
			// c.g:117:4: logic_add
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(117, 4);
			PushFollow(Follow._logic_add_in_value_expr651);
			logic_add25=logic_add();
			PopFollow();

			adaptor.AddChild(root_0, logic_add25.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_expr", 8);
			LeaveRule("value_expr", 8);
			LeaveRule_value_expr();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "value_expr"); }
		return retval;

	}
	// $ANTLR end "value_expr"

	partial void EnterRule_func_call();
	partial void LeaveRule_func_call();
	// $ANTLR start "func_call"
	// c.g:122:1: func_call : ID '(' ( value_expr ( ',' value_expr )* )? ')' -> ^( FUNCCALL ID ( ^( PARAMS ( value_expr )* ) )? ) ;
	[GrammarRule("func_call")]
	private AstParserRuleReturnScope<object, IToken> func_call()
	{
		EnterRule_func_call();
		EnterRule("func_call", 9);
		TraceIn("func_call", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID26 = default(IToken);
		IToken char_literal27 = default(IToken);
		IToken char_literal29 = default(IToken);
		IToken char_literal31 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_expr28 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr30 = default(AstParserRuleReturnScope<object, IToken>);

		object ID26_tree = default(object);
		object char_literal27_tree = default(object);
		object char_literal29_tree = default(object);
		object char_literal31_tree = default(object);
		RewriteRuleITokenStream stream_33=new RewriteRuleITokenStream(adaptor,"token 33");
		RewriteRuleITokenStream stream_34=new RewriteRuleITokenStream(adaptor,"token 34");
		RewriteRuleITokenStream stream_35=new RewriteRuleITokenStream(adaptor,"token 35");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_value_expr=new RewriteRuleSubtreeStream(adaptor,"rule value_expr");
		try { DebugEnterRule(GrammarFileName, "func_call");
		DebugLocation(122, 1);
		try
		{
			// c.g:123:2: ( ID '(' ( value_expr ( ',' value_expr )* )? ')' -> ^( FUNCCALL ID ( ^( PARAMS ( value_expr )* ) )? ) )
			DebugEnterAlt(1);
			// c.g:123:4: ID '(' ( value_expr ( ',' value_expr )* )? ')'
			{
			DebugLocation(123, 4);
			ID26=(IToken)Match(input,ID,Follow._ID_in_func_call666);  
			stream_ID.Add(ID26);

			DebugLocation(123, 7);
			char_literal27=(IToken)Match(input,33,Follow._33_in_func_call668);  
			stream_33.Add(char_literal27);

			DebugLocation(123, 11);
			// c.g:123:11: ( value_expr ( ',' value_expr )* )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==ID||LA9_1==LOGIC||LA9_1==NUMBER||LA9_1==STRING||LA9_1==33))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// c.g:123:13: value_expr ( ',' value_expr )*
				{
				DebugLocation(123, 13);
				PushFollow(Follow._value_expr_in_func_call672);
				value_expr28=value_expr();
				PopFollow();

				stream_value_expr.Add(value_expr28.Tree);
				DebugLocation(123, 24);
				// c.g:123:24: ( ',' value_expr )*
				try { DebugEnterSubRule(8);
				while (true)
				{
					int alt8=2;
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if ((LA8_1==35))
					{
						alt8 = 1;
					}


					} finally { DebugExitDecision(8); }
					switch ( alt8 )
					{
					case 1:
						DebugEnterAlt(1);
						// c.g:123:26: ',' value_expr
						{
						DebugLocation(123, 26);
						char_literal29=(IToken)Match(input,35,Follow._35_in_func_call676);  
						stream_35.Add(char_literal29);

						DebugLocation(123, 30);
						PushFollow(Follow._value_expr_in_func_call678);
						value_expr30=value_expr();
						PopFollow();

						stream_value_expr.Add(value_expr30.Tree);

						}
						break;

					default:
						goto loop8;
					}
				}

				loop8:
					;

				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(123, 46);
			char_literal31=(IToken)Match(input,34,Follow._34_in_func_call685);  
			stream_34.Add(char_literal31);



			{
			// AST REWRITE
			// elements: ID, value_expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 123:50: -> ^( FUNCCALL ID ( ^( PARAMS ( value_expr )* ) )? )
			{
				DebugLocation(123, 53);
				// c.g:123:53: ^( FUNCCALL ID ( ^( PARAMS ( value_expr )* ) )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(123, 55);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCCALL, "FUNCCALL"), root_1);

				DebugLocation(123, 64);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(123, 67);
				// c.g:123:67: ( ^( PARAMS ( value_expr )* ) )?
				if (stream_value_expr.HasNext)
				{
					DebugLocation(123, 69);
					// c.g:123:69: ^( PARAMS ( value_expr )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(123, 71);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAMS, "PARAMS"), root_2);

					DebugLocation(123, 78);
					// c.g:123:78: ( value_expr )*
					while ( stream_value_expr.HasNext )
					{
						DebugLocation(123, 78);
						adaptor.AddChild(root_2, stream_value_expr.NextTree());

					}
					stream_value_expr.Reset();

					adaptor.AddChild(root_1, root_2);
					}

				}
				stream_value_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_call", 9);
			LeaveRule("func_call", 9);
			LeaveRule_func_call();
		}
		DebugLocation(124, 1);
		} finally { DebugExitRule(GrammarFileName, "func_call"); }
		return retval;

	}
	// $ANTLR end "func_call"

	partial void EnterRule_simple_expr();
	partial void LeaveRule_simple_expr();
	// $ANTLR start "simple_expr"
	// c.g:126:1: simple_expr : ( ID ASSIGN ^ value_expr | func_call | READ ^ '(' ! ID ( ',' ! ID )* ')' !| WRITE ^ '(' ! value_expr ( ',' ! value_expr )* ')' !);
	[GrammarRule("simple_expr")]
	private AstParserRuleReturnScope<object, IToken> simple_expr()
	{
		EnterRule_simple_expr();
		EnterRule("simple_expr", 10);
		TraceIn("simple_expr", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID32 = default(IToken);
		IToken ASSIGN33 = default(IToken);
		IToken READ36 = default(IToken);
		IToken char_literal37 = default(IToken);
		IToken ID38 = default(IToken);
		IToken char_literal39 = default(IToken);
		IToken ID40 = default(IToken);
		IToken char_literal41 = default(IToken);
		IToken WRITE42 = default(IToken);
		IToken char_literal43 = default(IToken);
		IToken char_literal45 = default(IToken);
		IToken char_literal47 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_expr34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> func_call35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr44 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr46 = default(AstParserRuleReturnScope<object, IToken>);

		object ID32_tree = default(object);
		object ASSIGN33_tree = default(object);
		object READ36_tree = default(object);
		object char_literal37_tree = default(object);
		object ID38_tree = default(object);
		object char_literal39_tree = default(object);
		object ID40_tree = default(object);
		object char_literal41_tree = default(object);
		object WRITE42_tree = default(object);
		object char_literal43_tree = default(object);
		object char_literal45_tree = default(object);
		object char_literal47_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "simple_expr");
		DebugLocation(126, 1);
		try
		{
			// c.g:127:2: ( ID ASSIGN ^ value_expr | func_call | READ ^ '(' ! ID ( ',' ! ID )* ')' !| WRITE ^ '(' ! value_expr ( ',' ! value_expr )* ')' !)
			int alt12=4;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA12_2 = input.LA(2);

				if ((LA12_2==ASSIGN))
				{
					alt12 = 1;
				}
				else if ((LA12_2==33))
				{
					alt12 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case READ:
				{
				alt12 = 3;
				}
				break;
			case WRITE:
				{
				alt12 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// c.g:127:4: ID ASSIGN ^ value_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(127, 4);
				ID32=(IToken)Match(input,ID,Follow._ID_in_simple_expr717); 
				ID32_tree = (object)adaptor.Create(ID32);
				adaptor.AddChild(root_0, ID32_tree);
				DebugLocation(127, 13);
				ASSIGN33=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_simple_expr719); 
				ASSIGN33_tree = (object)adaptor.Create(ASSIGN33);
				root_0 = (object)adaptor.BecomeRoot(ASSIGN33_tree, root_0);
				DebugLocation(127, 15);
				PushFollow(Follow._value_expr_in_simple_expr722);
				value_expr34=value_expr();
				PopFollow();

				adaptor.AddChild(root_0, value_expr34.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// c.g:128:4: func_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(128, 4);
				PushFollow(Follow._func_call_in_simple_expr728);
				func_call35=func_call();
				PopFollow();

				adaptor.AddChild(root_0, func_call35.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// c.g:130:4: READ ^ '(' ! ID ( ',' ! ID )* ')' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(130, 8);
				READ36=(IToken)Match(input,READ,Follow._READ_in_simple_expr736); 
				READ36_tree = (object)adaptor.Create(READ36);
				root_0 = (object)adaptor.BecomeRoot(READ36_tree, root_0);
				DebugLocation(130, 13);
				char_literal37=(IToken)Match(input,33,Follow._33_in_simple_expr739); 
				DebugLocation(130, 15);
				ID38=(IToken)Match(input,ID,Follow._ID_in_simple_expr742); 
				ID38_tree = (object)adaptor.Create(ID38);
				adaptor.AddChild(root_0, ID38_tree);
				DebugLocation(130, 18);
				// c.g:130:18: ( ',' ! ID )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if ((LA10_1==35))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// c.g:130:20: ',' ! ID
						{
						DebugLocation(130, 23);
						char_literal39=(IToken)Match(input,35,Follow._35_in_simple_expr746); 
						DebugLocation(130, 25);
						ID40=(IToken)Match(input,ID,Follow._ID_in_simple_expr749); 
						ID40_tree = (object)adaptor.Create(ID40);
						adaptor.AddChild(root_0, ID40_tree);

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(130, 33);
				char_literal41=(IToken)Match(input,34,Follow._34_in_simple_expr753); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// c.g:131:4: WRITE ^ '(' ! value_expr ( ',' ! value_expr )* ')' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(131, 9);
				WRITE42=(IToken)Match(input,WRITE,Follow._WRITE_in_simple_expr759); 
				WRITE42_tree = (object)adaptor.Create(WRITE42);
				root_0 = (object)adaptor.BecomeRoot(WRITE42_tree, root_0);
				DebugLocation(131, 14);
				char_literal43=(IToken)Match(input,33,Follow._33_in_simple_expr762); 
				DebugLocation(131, 16);
				PushFollow(Follow._value_expr_in_simple_expr765);
				value_expr44=value_expr();
				PopFollow();

				adaptor.AddChild(root_0, value_expr44.Tree);
				DebugLocation(131, 27);
				// c.g:131:27: ( ',' ! value_expr )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if ((LA11_1==35))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// c.g:131:29: ',' ! value_expr
						{
						DebugLocation(131, 32);
						char_literal45=(IToken)Match(input,35,Follow._35_in_simple_expr769); 
						DebugLocation(131, 34);
						PushFollow(Follow._value_expr_in_simple_expr772);
						value_expr46=value_expr();
						PopFollow();

						adaptor.AddChild(root_0, value_expr46.Tree);

						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(131, 50);
				char_literal47=(IToken)Match(input,34,Follow._34_in_simple_expr776); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simple_expr", 10);
			LeaveRule("simple_expr", 10);
			LeaveRule_simple_expr();
		}
		DebugLocation(133, 1);
		} finally { DebugExitRule(GrammarFileName, "simple_expr"); }
		return retval;

	}
	// $ANTLR end "simple_expr"

	partial void EnterRule_construction();
	partial void LeaveRule_construction();
	// $ANTLR start "construction"
	// c.g:136:1: construction : ( simple_expr ';' !| '{' ( construction )* '}' -> ^( BLOCK ( construction )* ) | IF ^ '(' ! value_expr ')' ! construction ( ELSE ! construction )? | FOR '(' simple_expr ';' value_expr ';' simple_expr ')' construction -> ^( FOR simple_expr value_expr simple_expr construction ) );
	[GrammarRule("construction")]
	private AstParserRuleReturnScope<object, IToken> construction()
	{
		EnterRule_construction();
		EnterRule("construction", 11);
		TraceIn("construction", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal49 = default(IToken);
		IToken char_literal50 = default(IToken);
		IToken char_literal52 = default(IToken);
		IToken IF53 = default(IToken);
		IToken char_literal54 = default(IToken);
		IToken char_literal56 = default(IToken);
		IToken ELSE58 = default(IToken);
		IToken FOR60 = default(IToken);
		IToken char_literal61 = default(IToken);
		IToken char_literal63 = default(IToken);
		IToken char_literal65 = default(IToken);
		IToken char_literal67 = default(IToken);
		AstParserRuleReturnScope<object, IToken> simple_expr48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> construction51 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr55 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> construction57 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> construction59 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_expr62 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_expr66 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> construction68 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal49_tree = default(object);
		object char_literal50_tree = default(object);
		object char_literal52_tree = default(object);
		object IF53_tree = default(object);
		object char_literal54_tree = default(object);
		object char_literal56_tree = default(object);
		object ELSE58_tree = default(object);
		object FOR60_tree = default(object);
		object char_literal61_tree = default(object);
		object char_literal63_tree = default(object);
		object char_literal65_tree = default(object);
		object char_literal67_tree = default(object);
		RewriteRuleITokenStream stream_33=new RewriteRuleITokenStream(adaptor,"token 33");
		RewriteRuleITokenStream stream_34=new RewriteRuleITokenStream(adaptor,"token 34");
		RewriteRuleITokenStream stream_36=new RewriteRuleITokenStream(adaptor,"token 36");
		RewriteRuleITokenStream stream_37=new RewriteRuleITokenStream(adaptor,"token 37");
		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleSubtreeStream stream_simple_expr=new RewriteRuleSubtreeStream(adaptor,"rule simple_expr");
		RewriteRuleSubtreeStream stream_value_expr=new RewriteRuleSubtreeStream(adaptor,"rule value_expr");
		RewriteRuleSubtreeStream stream_construction=new RewriteRuleSubtreeStream(adaptor,"rule construction");
		try { DebugEnterRule(GrammarFileName, "construction");
		DebugLocation(136, 1);
		try
		{
			// c.g:137:2: ( simple_expr ';' !| '{' ( construction )* '}' -> ^( BLOCK ( construction )* ) | IF ^ '(' ! value_expr ')' ! construction ( ELSE ! construction )? | FOR '(' simple_expr ';' value_expr ';' simple_expr ')' construction -> ^( FOR simple_expr value_expr simple_expr construction ) )
			int alt15=4;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case ID:
			case READ:
			case WRITE:
				{
				alt15 = 1;
				}
				break;
			case 37:
				{
				alt15 = 2;
				}
				break;
			case IF:
				{
				alt15 = 3;
				}
				break;
			case FOR:
				{
				alt15 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// c.g:137:4: simple_expr ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(137, 4);
				PushFollow(Follow._simple_expr_in_construction791);
				simple_expr48=simple_expr();
				PopFollow();

				adaptor.AddChild(root_0, simple_expr48.Tree);
				DebugLocation(137, 19);
				char_literal49=(IToken)Match(input,36,Follow._36_in_construction793); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// c.g:139:4: '{' ( construction )* '}'
				{
				DebugLocation(139, 4);
				char_literal50=(IToken)Match(input,37,Follow._37_in_construction801);  
				stream_37.Add(char_literal50);

				DebugLocation(139, 8);
				// c.g:139:8: ( construction )*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==FOR||(LA13_1>=ID && LA13_1<=IF)||LA13_1==READ||LA13_1==WRITE||LA13_1==37))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// c.g:139:8: construction
						{
						DebugLocation(139, 8);
						PushFollow(Follow._construction_in_construction803);
						construction51=construction();
						PopFollow();

						stream_construction.Add(construction51.Tree);

						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }

				DebugLocation(139, 22);
				char_literal52=(IToken)Match(input,38,Follow._38_in_construction806);  
				stream_38.Add(char_literal52);



				{
				// AST REWRITE
				// elements: construction
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 139:26: -> ^( BLOCK ( construction )* )
				{
					DebugLocation(139, 29);
					// c.g:139:29: ^( BLOCK ( construction )* )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(139, 31);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, "BLOCK"), root_1);

					DebugLocation(139, 37);
					// c.g:139:37: ( construction )*
					while ( stream_construction.HasNext )
					{
						DebugLocation(139, 37);
						adaptor.AddChild(root_1, stream_construction.NextTree());

					}
					stream_construction.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// c.g:140:4: IF ^ '(' ! value_expr ')' ! construction ( ELSE ! construction )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(140, 6);
				IF53=(IToken)Match(input,IF,Follow._IF_in_construction822); 
				IF53_tree = (object)adaptor.Create(IF53);
				root_0 = (object)adaptor.BecomeRoot(IF53_tree, root_0);
				DebugLocation(140, 11);
				char_literal54=(IToken)Match(input,33,Follow._33_in_construction825); 
				DebugLocation(140, 13);
				PushFollow(Follow._value_expr_in_construction828);
				value_expr55=value_expr();
				PopFollow();

				adaptor.AddChild(root_0, value_expr55.Tree);
				DebugLocation(140, 27);
				char_literal56=(IToken)Match(input,34,Follow._34_in_construction830); 
				DebugLocation(140, 29);
				PushFollow(Follow._construction_in_construction833);
				construction57=construction();
				PopFollow();

				adaptor.AddChild(root_0, construction57.Tree);
				DebugLocation(140, 42);
				// c.g:140:42: ( ELSE ! construction )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==ELSE))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// c.g:140:44: ELSE ! construction
					{
					DebugLocation(140, 48);
					ELSE58=(IToken)Match(input,ELSE,Follow._ELSE_in_construction837); 
					DebugLocation(140, 50);
					PushFollow(Follow._construction_in_construction840);
					construction59=construction();
					PopFollow();

					adaptor.AddChild(root_0, construction59.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(14); }


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// c.g:141:4: FOR '(' simple_expr ';' value_expr ';' simple_expr ')' construction
				{
				DebugLocation(141, 4);
				FOR60=(IToken)Match(input,FOR,Follow._FOR_in_construction848);  
				stream_FOR.Add(FOR60);

				DebugLocation(141, 8);
				char_literal61=(IToken)Match(input,33,Follow._33_in_construction850);  
				stream_33.Add(char_literal61);

				DebugLocation(141, 12);
				PushFollow(Follow._simple_expr_in_construction852);
				simple_expr62=simple_expr();
				PopFollow();

				stream_simple_expr.Add(simple_expr62.Tree);
				DebugLocation(141, 24);
				char_literal63=(IToken)Match(input,36,Follow._36_in_construction854);  
				stream_36.Add(char_literal63);

				DebugLocation(141, 28);
				PushFollow(Follow._value_expr_in_construction856);
				value_expr64=value_expr();
				PopFollow();

				stream_value_expr.Add(value_expr64.Tree);
				DebugLocation(141, 39);
				char_literal65=(IToken)Match(input,36,Follow._36_in_construction858);  
				stream_36.Add(char_literal65);

				DebugLocation(141, 43);
				PushFollow(Follow._simple_expr_in_construction860);
				simple_expr66=simple_expr();
				PopFollow();

				stream_simple_expr.Add(simple_expr66.Tree);
				DebugLocation(141, 55);
				char_literal67=(IToken)Match(input,34,Follow._34_in_construction862);  
				stream_34.Add(char_literal67);

				DebugLocation(141, 59);
				PushFollow(Follow._construction_in_construction864);
				construction68=construction();
				PopFollow();

				stream_construction.Add(construction68.Tree);


				{
				// AST REWRITE
				// elements: FOR, simple_expr, construction, simple_expr, value_expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 141:72: -> ^( FOR simple_expr value_expr simple_expr construction )
				{
					DebugLocation(141, 75);
					// c.g:141:75: ^( FOR simple_expr value_expr simple_expr construction )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(141, 77);
					root_1 = (object)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

					DebugLocation(141, 81);
					adaptor.AddChild(root_1, stream_simple_expr.NextTree());
					DebugLocation(141, 93);
					adaptor.AddChild(root_1, stream_value_expr.NextTree());
					DebugLocation(141, 104);
					adaptor.AddChild(root_1, stream_simple_expr.NextTree());
					DebugLocation(141, 116);
					adaptor.AddChild(root_1, stream_construction.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("construction", 11);
			LeaveRule("construction", 11);
			LeaveRule_construction();
		}
		DebugLocation(142, 1);
		} finally { DebugExitRule(GrammarFileName, "construction"); }
		return retval;

	}
	// $ANTLR end "construction"

	partial void EnterRule_result();
	partial void LeaveRule_result();
	// $ANTLR start "result"
	// c.g:145:1: result : ( construction )* EOF -> ^( PROGRAM ( construction )* ) ;
	[GrammarRule("result")]
	private AstParserRuleReturnScope<object, IToken> result()
	{
		EnterRule_result();
		EnterRule("result", 12);
		TraceIn("result", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF70 = default(IToken);
		AstParserRuleReturnScope<object, IToken> construction69 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF70_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_construction=new RewriteRuleSubtreeStream(adaptor,"rule construction");
		try { DebugEnterRule(GrammarFileName, "result");
		DebugLocation(145, 1);
		try
		{
			// c.g:146:2: ( ( construction )* EOF -> ^( PROGRAM ( construction )* ) )
			DebugEnterAlt(1);
			// c.g:146:4: ( construction )* EOF
			{
			DebugLocation(146, 4);
			// c.g:146:4: ( construction )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==FOR||(LA16_1>=ID && LA16_1<=IF)||LA16_1==READ||LA16_1==WRITE||LA16_1==37))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// c.g:146:4: construction
					{
					DebugLocation(146, 4);
					PushFollow(Follow._construction_in_result891);
					construction69=construction();
					PopFollow();

					stream_construction.Add(construction69.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(146, 18);
			EOF70=(IToken)Match(input,EOF,Follow._EOF_in_result894);  
			stream_EOF.Add(EOF70);



			{
			// AST REWRITE
			// elements: construction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 146:22: -> ^( PROGRAM ( construction )* )
			{
				DebugLocation(146, 25);
				// c.g:146:25: ^( PROGRAM ( construction )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(146, 28);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(146, 36);
				// c.g:146:36: ( construction )*
				while ( stream_construction.HasNext )
				{
					DebugLocation(146, 36);
					adaptor.AddChild(root_1, stream_construction.NextTree());

				}
				stream_construction.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("result", 12);
			LeaveRule("result", 12);
			LeaveRule_result();
		}
		DebugLocation(147, 1);
		} finally { DebugExitRule(GrammarFileName, "result"); }
		return retval;

	}
	// $ANTLR end "result"

	partial void EnterRule_execute();
	partial void LeaveRule_execute();
	// $ANTLR start "execute"
	// c.g:149:8: public execute : result ;
	[GrammarRule("execute")]
	public AstParserRuleReturnScope<object, IToken> execute()
	{
		EnterRule_execute();
		EnterRule("execute", 13);
		TraceIn("execute", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> result71 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "execute");
		DebugLocation(149, 1);
		try
		{
			// c.g:150:2: ( result )
			DebugEnterAlt(1);
			// c.g:150:4: result
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(150, 4);
			PushFollow(Follow._result_in_execute918);
			result71=result();
			PopFollow();

			adaptor.AddChild(root_0, result71.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("execute", 13);
			LeaveRule("execute", 13);
			LeaveRule_execute();
		}
		DebugLocation(151, 1);
		} finally { DebugExitRule(GrammarFileName, "execute"); }
		return retval;

	}
	// $ANTLR end "execute"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _NUMBER_in_primitive_value450 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_primitive_value455 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LOGIC_in_primitive_value460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primitive_value465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_call_in_primitive_value470 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _33_in_value_group481 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_add_in_value_group484 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_value_group486 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitive_value_in_value_group491 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _value_group_in_value_mult503 = new BitSet(new ulong[]{0x400082UL});
		public static readonly BitSet _set_in_value_mult507 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_group_in_value_mult518 = new BitSet(new ulong[]{0x400082UL});
		public static readonly BitSet _value_mult_in_value_add533 = new BitSet(new ulong[]{0x40000012UL});
		public static readonly BitSet _set_in_value_add537 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_mult_in_value_add548 = new BitSet(new ulong[]{0x40000012UL});
		public static readonly BitSet _value_add_in_logic_group564 = new BitSet(new ulong[]{0x923202UL});
		public static readonly BitSet _set_in_logic_group568 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_add_in_logic_group595 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logic_group_in_logic_mult610 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _LMUL_in_logic_mult614 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _logic_group_in_logic_mult617 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _logic_mult_in_logic_add631 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _LADD_in_logic_add635 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _logic_mult_in_logic_add638 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _logic_add_in_value_expr651 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_func_call666 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_func_call668 = new BitSet(new ulong[]{0x621084000UL});
		public static readonly BitSet _value_expr_in_func_call672 = new BitSet(new ulong[]{0xC00000000UL});
		public static readonly BitSet _35_in_func_call676 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_expr_in_func_call678 = new BitSet(new ulong[]{0xC00000000UL});
		public static readonly BitSet _34_in_func_call685 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_simple_expr717 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_simple_expr719 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_expr_in_simple_expr722 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_call_in_simple_expr728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _READ_in_simple_expr736 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_simple_expr739 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_simple_expr742 = new BitSet(new ulong[]{0xC00000000UL});
		public static readonly BitSet _35_in_simple_expr746 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_simple_expr749 = new BitSet(new ulong[]{0xC00000000UL});
		public static readonly BitSet _34_in_simple_expr753 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WRITE_in_simple_expr759 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_simple_expr762 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_expr_in_simple_expr765 = new BitSet(new ulong[]{0xC00000000UL});
		public static readonly BitSet _35_in_simple_expr769 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_expr_in_simple_expr772 = new BitSet(new ulong[]{0xC00000000UL});
		public static readonly BitSet _34_in_simple_expr776 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simple_expr_in_construction791 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _36_in_construction793 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _37_in_construction801 = new BitSet(new ulong[]{0x608800C400UL});
		public static readonly BitSet _construction_in_construction803 = new BitSet(new ulong[]{0x608800C400UL});
		public static readonly BitSet _38_in_construction806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_construction822 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_construction825 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_expr_in_construction828 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_construction830 = new BitSet(new ulong[]{0x208800C400UL});
		public static readonly BitSet _construction_in_construction833 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _ELSE_in_construction837 = new BitSet(new ulong[]{0x208800C400UL});
		public static readonly BitSet _construction_in_construction840 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_construction848 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _33_in_construction850 = new BitSet(new ulong[]{0x88004000UL});
		public static readonly BitSet _simple_expr_in_construction852 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _36_in_construction854 = new BitSet(new ulong[]{0x221084000UL});
		public static readonly BitSet _value_expr_in_construction856 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _36_in_construction858 = new BitSet(new ulong[]{0x88004000UL});
		public static readonly BitSet _simple_expr_in_construction860 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _34_in_construction862 = new BitSet(new ulong[]{0x208800C400UL});
		public static readonly BitSet _construction_in_construction864 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _construction_in_result891 = new BitSet(new ulong[]{0x208800C400UL});
		public static readonly BitSet _EOF_in_result894 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _result_in_execute918 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  t_comp 
