//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5 C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g 2015-10-19 17:08:39

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  t_comp 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5")]
[System.CLSCompliant(false)]
public partial class cParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "ASSIGN", "BLOCK", "BOOL_YTPE", "CALL_PARAMS", "DIV", "ELSE", "EQUALS", "FOR", "FUNCCALL", "GE", "GT", "ID", "IF", "INT_TYPE", "LADD", "LE", "LMUL", "LOGIC", "LT", "ML_COMMENT", "MUL", "NEQUALS", "NUMBER", "PROGRAM", "READ", "SL_COMMENT", "STRING", "STRING_TYPE", "SUB", "WRITE", "WS", "'('", "')'", "','", "';'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int ADD=4;
	public const int ASSIGN=5;
	public const int BLOCK=6;
	public const int BOOL_YTPE=7;
	public const int CALL_PARAMS=8;
	public const int DIV=9;
	public const int ELSE=10;
	public const int EQUALS=11;
	public const int FOR=12;
	public const int FUNCCALL=13;
	public const int GE=14;
	public const int GT=15;
	public const int ID=16;
	public const int IF=17;
	public const int INT_TYPE=18;
	public const int LADD=19;
	public const int LE=20;
	public const int LMUL=21;
	public const int LOGIC=22;
	public const int LT=23;
	public const int ML_COMMENT=24;
	public const int MUL=25;
	public const int NEQUALS=26;
	public const int NUMBER=27;
	public const int PROGRAM=28;
	public const int READ=29;
	public const int SL_COMMENT=30;
	public const int STRING=31;
	public const int STRING_TYPE=32;
	public const int SUB=33;
	public const int WRITE=34;
	public const int WS=35;

	public cParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public cParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return cParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_primitive_value();
	partial void LeaveRule_primitive_value();
	// $ANTLR start "primitive_value"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:87:1: primitive_value : ( NUMBER | STRING | LOGIC | ID | func_call );
	[GrammarRule("primitive_value")]
	private AstParserRuleReturnScope<object, IToken> primitive_value()
	{
		EnterRule_primitive_value();
		EnterRule("primitive_value", 1);
		TraceIn("primitive_value", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUMBER1 = default(IToken);
		IToken STRING2 = default(IToken);
		IToken LOGIC3 = default(IToken);
		IToken ID4 = default(IToken);
		AstParserRuleReturnScope<object, IToken> func_call5 = default(AstParserRuleReturnScope<object, IToken>);

		object NUMBER1_tree = default(object);
		object STRING2_tree = default(object);
		object LOGIC3_tree = default(object);
		object ID4_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "primitive_value");
		DebugLocation(87, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:88:2: ( NUMBER | STRING | LOGIC | ID | func_call )
			int alt1=5;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case NUMBER:
				{
				alt1 = 1;
				}
				break;
			case STRING:
				{
				alt1 = 2;
				}
				break;
			case LOGIC:
				{
				alt1 = 3;
				}
				break;
			case ID:
				{
				int LA1_2 = input.LA(2);

				if ((LA1_2==36))
				{
					alt1 = 5;
				}
				else if ((LA1_2==ADD||LA1_2==DIV||LA1_2==EQUALS||(LA1_2>=GE && LA1_2<=GT)||(LA1_2>=LADD && LA1_2<=LMUL)||LA1_2==LT||(LA1_2>=MUL && LA1_2<=NEQUALS)||LA1_2==SUB||(LA1_2>=37 && LA1_2<=39)))
				{
					alt1 = 4;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:88:4: NUMBER
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 4);
				NUMBER1=(IToken)Match(input,NUMBER,Follow._NUMBER_in_primitive_value471); 
				NUMBER1_tree = (object)adaptor.Create(NUMBER1);
				adaptor.AddChild(root_0, NUMBER1_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:89:4: STRING
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(89, 4);
				STRING2=(IToken)Match(input,STRING,Follow._STRING_in_primitive_value476); 
				STRING2_tree = (object)adaptor.Create(STRING2);
				adaptor.AddChild(root_0, STRING2_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:90:4: LOGIC
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(90, 4);
				LOGIC3=(IToken)Match(input,LOGIC,Follow._LOGIC_in_primitive_value481); 
				LOGIC3_tree = (object)adaptor.Create(LOGIC3);
				adaptor.AddChild(root_0, LOGIC3_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:91:4: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(91, 4);
				ID4=(IToken)Match(input,ID,Follow._ID_in_primitive_value486); 
				ID4_tree = (object)adaptor.Create(ID4);
				adaptor.AddChild(root_0, ID4_tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:92:4: func_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(92, 4);
				PushFollow(Follow._func_call_in_primitive_value491);
				func_call5=func_call();
				PopFollow();

				adaptor.AddChild(root_0, func_call5.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primitive_value", 1);
			LeaveRule("primitive_value", 1);
			LeaveRule_primitive_value();
		}
		DebugLocation(93, 1);
		} finally { DebugExitRule(GrammarFileName, "primitive_value"); }
		return retval;

	}
	// $ANTLR end "primitive_value"

	partial void EnterRule_value_group();
	partial void LeaveRule_value_group();
	// $ANTLR start "value_group"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:95:1: value_group : ( '(' ! value_add ')' !| primitive_value );
	[GrammarRule("value_group")]
	private AstParserRuleReturnScope<object, IToken> value_group()
	{
		EnterRule_value_group();
		EnterRule("value_group", 2);
		TraceIn("value_group", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal6 = default(IToken);
		IToken char_literal8 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_add7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primitive_value9 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal6_tree = default(object);
		object char_literal8_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_group");
		DebugLocation(95, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:96:2: ( '(' ! value_add ')' !| primitive_value )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==36))
			{
				alt2 = 1;
			}
			else if ((LA2_1==ID||LA2_1==LOGIC||LA2_1==NUMBER||LA2_1==STRING))
			{
				alt2 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:96:4: '(' ! value_add ')' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(96, 7);
				char_literal6=(IToken)Match(input,36,Follow._36_in_value_group502); 
				DebugLocation(96, 9);
				PushFollow(Follow._value_add_in_value_group505);
				value_add7=value_add();
				PopFollow();

				adaptor.AddChild(root_0, value_add7.Tree);
				DebugLocation(96, 22);
				char_literal8=(IToken)Match(input,37,Follow._37_in_value_group507); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:96:26: primitive_value
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(96, 26);
				PushFollow(Follow._primitive_value_in_value_group512);
				primitive_value9=primitive_value();
				PopFollow();

				adaptor.AddChild(root_0, primitive_value9.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_group", 2);
			LeaveRule("value_group", 2);
			LeaveRule_value_group();
		}
		DebugLocation(97, 1);
		} finally { DebugExitRule(GrammarFileName, "value_group"); }
		return retval;

	}
	// $ANTLR end "value_group"

	partial void EnterRule_value_mult();
	partial void LeaveRule_value_mult();
	// $ANTLR start "value_mult"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:99:1: value_mult : value_group ( ( MUL | DIV ) ^ value_group )* ;
	[GrammarRule("value_mult")]
	private AstParserRuleReturnScope<object, IToken> value_mult()
	{
		EnterRule_value_mult();
		EnterRule("value_mult", 3);
		TraceIn("value_mult", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set11 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_group10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_group12 = default(AstParserRuleReturnScope<object, IToken>);

		object set11_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_mult");
		DebugLocation(99, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:100:2: ( value_group ( ( MUL | DIV ) ^ value_group )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:100:4: value_group ( ( MUL | DIV ) ^ value_group )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(100, 4);
			PushFollow(Follow._value_group_in_value_mult524);
			value_group10=value_group();
			PopFollow();

			adaptor.AddChild(root_0, value_group10.Tree);
			DebugLocation(100, 16);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:100:16: ( ( MUL | DIV ) ^ value_group )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==DIV||LA3_1==MUL))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:100:18: ( MUL | DIV ) ^ value_group
					{
					DebugLocation(100, 31);

					set11=(IToken)input.LT(1);
					set11=(IToken)input.LT(1);
					if (input.LA(1)==DIV||input.LA(1)==MUL)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set11), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(100, 33);
					PushFollow(Follow._value_group_in_value_mult539);
					value_group12=value_group();
					PopFollow();

					adaptor.AddChild(root_0, value_group12.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_mult", 3);
			LeaveRule("value_mult", 3);
			LeaveRule_value_mult();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "value_mult"); }
		return retval;

	}
	// $ANTLR end "value_mult"

	partial void EnterRule_value_add();
	partial void LeaveRule_value_add();
	// $ANTLR start "value_add"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:103:1: value_add : value_mult ( ( ADD | SUB ) ^ value_mult )* ;
	[GrammarRule("value_add")]
	private AstParserRuleReturnScope<object, IToken> value_add()
	{
		EnterRule_value_add();
		EnterRule("value_add", 4);
		TraceIn("value_add", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set14 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_mult13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_mult15 = default(AstParserRuleReturnScope<object, IToken>);

		object set14_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_add");
		DebugLocation(103, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:104:2: ( value_mult ( ( ADD | SUB ) ^ value_mult )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:104:4: value_mult ( ( ADD | SUB ) ^ value_mult )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(104, 4);
			PushFollow(Follow._value_mult_in_value_add554);
			value_mult13=value_mult();
			PopFollow();

			adaptor.AddChild(root_0, value_mult13.Tree);
			DebugLocation(104, 15);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:104:15: ( ( ADD | SUB ) ^ value_mult )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==ADD||LA4_1==SUB))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:104:17: ( ADD | SUB ) ^ value_mult
					{
					DebugLocation(104, 30);

					set14=(IToken)input.LT(1);
					set14=(IToken)input.LT(1);
					if (input.LA(1)==ADD||input.LA(1)==SUB)
					{
						input.Consume();
						root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set14), root_0);
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(104, 32);
					PushFollow(Follow._value_mult_in_value_add569);
					value_mult15=value_mult();
					PopFollow();

					adaptor.AddChild(root_0, value_mult15.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_add", 4);
			LeaveRule("value_add", 4);
			LeaveRule_value_add();
		}
		DebugLocation(105, 1);
		} finally { DebugExitRule(GrammarFileName, "value_add"); }
		return retval;

	}
	// $ANTLR end "value_add"

	partial void EnterRule_logic_group();
	partial void LeaveRule_logic_group();
	// $ANTLR start "logic_group"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:108:1: logic_group : value_add ( ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add )? ;
	[GrammarRule("logic_group")]
	private AstParserRuleReturnScope<object, IToken> logic_group()
	{
		EnterRule_logic_group();
		EnterRule("logic_group", 5);
		TraceIn("logic_group", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set17 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_add16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_add18 = default(AstParserRuleReturnScope<object, IToken>);

		object set17_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logic_group");
		DebugLocation(108, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:109:2: ( value_add ( ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add )? )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:109:4: value_add ( ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(109, 4);
			PushFollow(Follow._value_add_in_logic_group585);
			value_add16=value_add();
			PopFollow();

			adaptor.AddChild(root_0, value_add16.Tree);
			DebugLocation(109, 14);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:109:14: ( ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==EQUALS||(LA5_1>=GE && LA5_1<=GT)||LA5_1==LE||LA5_1==LT||LA5_1==NEQUALS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:109:16: ( GE | LE | NEQUALS | EQUALS | GT | LT ) ^ value_add
				{
				DebugLocation(109, 56);

				set17=(IToken)input.LT(1);
				set17=(IToken)input.LT(1);
				if (input.LA(1)==EQUALS||(input.LA(1)>=GE && input.LA(1)<=GT)||input.LA(1)==LE||input.LA(1)==LT||input.LA(1)==NEQUALS)
				{
					input.Consume();
					root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set17), root_0);
					state.errorRecovery=false;
				}
				else
				{
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(109, 58);
				PushFollow(Follow._value_add_in_logic_group616);
				value_add18=value_add();
				PopFollow();

				adaptor.AddChild(root_0, value_add18.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logic_group", 5);
			LeaveRule("logic_group", 5);
			LeaveRule_logic_group();
		}
		DebugLocation(110, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_group"); }
		return retval;

	}
	// $ANTLR end "logic_group"

	partial void EnterRule_logic_mult();
	partial void LeaveRule_logic_mult();
	// $ANTLR start "logic_mult"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:112:1: logic_mult : logic_group ( LMUL ^ logic_group )* ;
	[GrammarRule("logic_mult")]
	private AstParserRuleReturnScope<object, IToken> logic_mult()
	{
		EnterRule_logic_mult();
		EnterRule("logic_mult", 6);
		TraceIn("logic_mult", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LMUL20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_group19 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_group21 = default(AstParserRuleReturnScope<object, IToken>);

		object LMUL20_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logic_mult");
		DebugLocation(112, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:113:2: ( logic_group ( LMUL ^ logic_group )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:113:4: logic_group ( LMUL ^ logic_group )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(113, 4);
			PushFollow(Follow._logic_group_in_logic_mult631);
			logic_group19=logic_group();
			PopFollow();

			adaptor.AddChild(root_0, logic_group19.Tree);
			DebugLocation(113, 16);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:113:16: ( LMUL ^ logic_group )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==LMUL))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:113:18: LMUL ^ logic_group
					{
					DebugLocation(113, 22);
					LMUL20=(IToken)Match(input,LMUL,Follow._LMUL_in_logic_mult635); 
					LMUL20_tree = (object)adaptor.Create(LMUL20);
					root_0 = (object)adaptor.BecomeRoot(LMUL20_tree, root_0);
					DebugLocation(113, 24);
					PushFollow(Follow._logic_group_in_logic_mult638);
					logic_group21=logic_group();
					PopFollow();

					adaptor.AddChild(root_0, logic_group21.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logic_mult", 6);
			LeaveRule("logic_mult", 6);
			LeaveRule_logic_mult();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_mult"); }
		return retval;

	}
	// $ANTLR end "logic_mult"

	partial void EnterRule_logic_add();
	partial void LeaveRule_logic_add();
	// $ANTLR start "logic_add"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:116:1: logic_add : logic_mult ( LADD ^ logic_mult )* ;
	[GrammarRule("logic_add")]
	private AstParserRuleReturnScope<object, IToken> logic_add()
	{
		EnterRule_logic_add();
		EnterRule("logic_add", 7);
		TraceIn("logic_add", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LADD23 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_mult22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_mult24 = default(AstParserRuleReturnScope<object, IToken>);

		object LADD23_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logic_add");
		DebugLocation(116, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:117:2: ( logic_mult ( LADD ^ logic_mult )* )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:117:4: logic_mult ( LADD ^ logic_mult )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(117, 4);
			PushFollow(Follow._logic_mult_in_logic_add652);
			logic_mult22=logic_mult();
			PopFollow();

			adaptor.AddChild(root_0, logic_mult22.Tree);
			DebugLocation(117, 15);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:117:15: ( LADD ^ logic_mult )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==LADD))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:117:17: LADD ^ logic_mult
					{
					DebugLocation(117, 21);
					LADD23=(IToken)Match(input,LADD,Follow._LADD_in_logic_add656); 
					LADD23_tree = (object)adaptor.Create(LADD23);
					root_0 = (object)adaptor.BecomeRoot(LADD23_tree, root_0);
					DebugLocation(117, 23);
					PushFollow(Follow._logic_mult_in_logic_add659);
					logic_mult24=logic_mult();
					PopFollow();

					adaptor.AddChild(root_0, logic_mult24.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logic_add", 7);
			LeaveRule("logic_add", 7);
			LeaveRule_logic_add();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_add"); }
		return retval;

	}
	// $ANTLR end "logic_add"

	partial void EnterRule_value_expr();
	partial void LeaveRule_value_expr();
	// $ANTLR start "value_expr"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:120:1: value_expr : logic_add ;
	[GrammarRule("value_expr")]
	private AstParserRuleReturnScope<object, IToken> value_expr()
	{
		EnterRule_value_expr();
		EnterRule("value_expr", 8);
		TraceIn("value_expr", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> logic_add25 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "value_expr");
		DebugLocation(120, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:121:2: ( logic_add )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:121:4: logic_add
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(121, 4);
			PushFollow(Follow._logic_add_in_value_expr672);
			logic_add25=logic_add();
			PopFollow();

			adaptor.AddChild(root_0, logic_add25.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_expr", 8);
			LeaveRule("value_expr", 8);
			LeaveRule_value_expr();
		}
		DebugLocation(122, 1);
		} finally { DebugExitRule(GrammarFileName, "value_expr"); }
		return retval;

	}
	// $ANTLR end "value_expr"

	partial void EnterRule_func_call();
	partial void LeaveRule_func_call();
	// $ANTLR start "func_call"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:126:1: func_call : ID '(' ( value_expr ( ',' value_expr )* )? ')' -> ^( FUNCCALL ID ( ^( CALL_PARAMS ( value_expr )* ) )? ) ;
	[GrammarRule("func_call")]
	private AstParserRuleReturnScope<object, IToken> func_call()
	{
		EnterRule_func_call();
		EnterRule("func_call", 9);
		TraceIn("func_call", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID26 = default(IToken);
		IToken char_literal27 = default(IToken);
		IToken char_literal29 = default(IToken);
		IToken char_literal31 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_expr28 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr30 = default(AstParserRuleReturnScope<object, IToken>);

		object ID26_tree = default(object);
		object char_literal27_tree = default(object);
		object char_literal29_tree = default(object);
		object char_literal31_tree = default(object);
		RewriteRuleITokenStream stream_36=new RewriteRuleITokenStream(adaptor,"token 36");
		RewriteRuleITokenStream stream_37=new RewriteRuleITokenStream(adaptor,"token 37");
		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_value_expr=new RewriteRuleSubtreeStream(adaptor,"rule value_expr");
		try { DebugEnterRule(GrammarFileName, "func_call");
		DebugLocation(126, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:2: ( ID '(' ( value_expr ( ',' value_expr )* )? ')' -> ^( FUNCCALL ID ( ^( CALL_PARAMS ( value_expr )* ) )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:4: ID '(' ( value_expr ( ',' value_expr )* )? ')'
			{
			DebugLocation(127, 4);
			ID26=(IToken)Match(input,ID,Follow._ID_in_func_call687);  
			stream_ID.Add(ID26);

			DebugLocation(127, 7);
			char_literal27=(IToken)Match(input,36,Follow._36_in_func_call689);  
			stream_36.Add(char_literal27);

			DebugLocation(127, 11);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:11: ( value_expr ( ',' value_expr )* )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==ID||LA9_1==LOGIC||LA9_1==NUMBER||LA9_1==STRING||LA9_1==36))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:13: value_expr ( ',' value_expr )*
				{
				DebugLocation(127, 13);
				PushFollow(Follow._value_expr_in_func_call693);
				value_expr28=value_expr();
				PopFollow();

				stream_value_expr.Add(value_expr28.Tree);
				DebugLocation(127, 24);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:24: ( ',' value_expr )*
				try { DebugEnterSubRule(8);
				while (true)
				{
					int alt8=2;
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if ((LA8_1==38))
					{
						alt8 = 1;
					}


					} finally { DebugExitDecision(8); }
					switch ( alt8 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:26: ',' value_expr
						{
						DebugLocation(127, 26);
						char_literal29=(IToken)Match(input,38,Follow._38_in_func_call697);  
						stream_38.Add(char_literal29);

						DebugLocation(127, 30);
						PushFollow(Follow._value_expr_in_func_call699);
						value_expr30=value_expr();
						PopFollow();

						stream_value_expr.Add(value_expr30.Tree);

						}
						break;

					default:
						goto loop8;
					}
				}

				loop8:
					;

				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(127, 46);
			char_literal31=(IToken)Match(input,37,Follow._37_in_func_call706);  
			stream_37.Add(char_literal31);



			{
			// AST REWRITE
			// elements: value_expr, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 127:50: -> ^( FUNCCALL ID ( ^( CALL_PARAMS ( value_expr )* ) )? )
			{
				DebugLocation(127, 53);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:53: ^( FUNCCALL ID ( ^( CALL_PARAMS ( value_expr )* ) )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(127, 55);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCCALL, "FUNCCALL"), root_1);

				DebugLocation(127, 64);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(127, 67);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:67: ( ^( CALL_PARAMS ( value_expr )* ) )?
				if (stream_value_expr.HasNext)
				{
					DebugLocation(127, 69);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:69: ^( CALL_PARAMS ( value_expr )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(127, 71);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL_PARAMS, "CALL_PARAMS"), root_2);

					DebugLocation(127, 83);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:127:83: ( value_expr )*
					while ( stream_value_expr.HasNext )
					{
						DebugLocation(127, 83);
						adaptor.AddChild(root_2, stream_value_expr.NextTree());

					}
					stream_value_expr.Reset();

					adaptor.AddChild(root_1, root_2);
					}

				}
				stream_value_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("func_call", 9);
			LeaveRule("func_call", 9);
			LeaveRule_func_call();
		}
		DebugLocation(128, 1);
		} finally { DebugExitRule(GrammarFileName, "func_call"); }
		return retval;

	}
	// $ANTLR end "func_call"

	partial void EnterRule_simple_expr();
	partial void LeaveRule_simple_expr();
	// $ANTLR start "simple_expr"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:130:1: simple_expr : ( ID ASSIGN ^ value_expr | func_call | READ ^ '(' ! ID ( ',' ! ID )* ')' !| WRITE ^ '(' ! value_expr ( ',' ! value_expr )* ')' !);
	[GrammarRule("simple_expr")]
	private AstParserRuleReturnScope<object, IToken> simple_expr()
	{
		EnterRule_simple_expr();
		EnterRule("simple_expr", 10);
		TraceIn("simple_expr", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID32 = default(IToken);
		IToken ASSIGN33 = default(IToken);
		IToken READ36 = default(IToken);
		IToken char_literal37 = default(IToken);
		IToken ID38 = default(IToken);
		IToken char_literal39 = default(IToken);
		IToken ID40 = default(IToken);
		IToken char_literal41 = default(IToken);
		IToken WRITE42 = default(IToken);
		IToken char_literal43 = default(IToken);
		IToken char_literal45 = default(IToken);
		IToken char_literal47 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_expr34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> func_call35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr44 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr46 = default(AstParserRuleReturnScope<object, IToken>);

		object ID32_tree = default(object);
		object ASSIGN33_tree = default(object);
		object READ36_tree = default(object);
		object char_literal37_tree = default(object);
		object ID38_tree = default(object);
		object char_literal39_tree = default(object);
		object ID40_tree = default(object);
		object char_literal41_tree = default(object);
		object WRITE42_tree = default(object);
		object char_literal43_tree = default(object);
		object char_literal45_tree = default(object);
		object char_literal47_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "simple_expr");
		DebugLocation(130, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:131:2: ( ID ASSIGN ^ value_expr | func_call | READ ^ '(' ! ID ( ',' ! ID )* ')' !| WRITE ^ '(' ! value_expr ( ',' ! value_expr )* ')' !)
			int alt12=4;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA12_2 = input.LA(2);

				if ((LA12_2==ASSIGN))
				{
					alt12 = 1;
				}
				else if ((LA12_2==36))
				{
					alt12 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case READ:
				{
				alt12 = 3;
				}
				break;
			case WRITE:
				{
				alt12 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:131:4: ID ASSIGN ^ value_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(131, 4);
				ID32=(IToken)Match(input,ID,Follow._ID_in_simple_expr738); 
				ID32_tree = (object)adaptor.Create(ID32);
				adaptor.AddChild(root_0, ID32_tree);
				DebugLocation(131, 13);
				ASSIGN33=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_simple_expr740); 
				ASSIGN33_tree = (object)adaptor.Create(ASSIGN33);
				root_0 = (object)adaptor.BecomeRoot(ASSIGN33_tree, root_0);
				DebugLocation(131, 15);
				PushFollow(Follow._value_expr_in_simple_expr743);
				value_expr34=value_expr();
				PopFollow();

				adaptor.AddChild(root_0, value_expr34.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:132:4: func_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(132, 4);
				PushFollow(Follow._func_call_in_simple_expr749);
				func_call35=func_call();
				PopFollow();

				adaptor.AddChild(root_0, func_call35.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:134:4: READ ^ '(' ! ID ( ',' ! ID )* ')' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(134, 8);
				READ36=(IToken)Match(input,READ,Follow._READ_in_simple_expr757); 
				READ36_tree = (object)adaptor.Create(READ36);
				root_0 = (object)adaptor.BecomeRoot(READ36_tree, root_0);
				DebugLocation(134, 13);
				char_literal37=(IToken)Match(input,36,Follow._36_in_simple_expr760); 
				DebugLocation(134, 15);
				ID38=(IToken)Match(input,ID,Follow._ID_in_simple_expr763); 
				ID38_tree = (object)adaptor.Create(ID38);
				adaptor.AddChild(root_0, ID38_tree);
				DebugLocation(134, 18);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:134:18: ( ',' ! ID )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if ((LA10_1==38))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:134:20: ',' ! ID
						{
						DebugLocation(134, 23);
						char_literal39=(IToken)Match(input,38,Follow._38_in_simple_expr767); 
						DebugLocation(134, 25);
						ID40=(IToken)Match(input,ID,Follow._ID_in_simple_expr770); 
						ID40_tree = (object)adaptor.Create(ID40);
						adaptor.AddChild(root_0, ID40_tree);

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(134, 33);
				char_literal41=(IToken)Match(input,37,Follow._37_in_simple_expr774); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:135:4: WRITE ^ '(' ! value_expr ( ',' ! value_expr )* ')' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(135, 9);
				WRITE42=(IToken)Match(input,WRITE,Follow._WRITE_in_simple_expr780); 
				WRITE42_tree = (object)adaptor.Create(WRITE42);
				root_0 = (object)adaptor.BecomeRoot(WRITE42_tree, root_0);
				DebugLocation(135, 14);
				char_literal43=(IToken)Match(input,36,Follow._36_in_simple_expr783); 
				DebugLocation(135, 16);
				PushFollow(Follow._value_expr_in_simple_expr786);
				value_expr44=value_expr();
				PopFollow();

				adaptor.AddChild(root_0, value_expr44.Tree);
				DebugLocation(135, 27);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:135:27: ( ',' ! value_expr )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if ((LA11_1==38))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:135:29: ',' ! value_expr
						{
						DebugLocation(135, 32);
						char_literal45=(IToken)Match(input,38,Follow._38_in_simple_expr790); 
						DebugLocation(135, 34);
						PushFollow(Follow._value_expr_in_simple_expr793);
						value_expr46=value_expr();
						PopFollow();

						adaptor.AddChild(root_0, value_expr46.Tree);

						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(135, 50);
				char_literal47=(IToken)Match(input,37,Follow._37_in_simple_expr797); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simple_expr", 10);
			LeaveRule("simple_expr", 10);
			LeaveRule_simple_expr();
		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "simple_expr"); }
		return retval;

	}
	// $ANTLR end "simple_expr"

	partial void EnterRule_construction();
	partial void LeaveRule_construction();
	// $ANTLR start "construction"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:140:1: construction : ( simple_expr ';' !| '{' ( construction )* '}' -> ^( BLOCK ( construction )* ) | IF ^ '(' ! value_expr ')' ! construction ( ELSE ! construction )? | FOR '(' simple_expr ';' value_expr ';' simple_expr ')' construction -> ^( FOR simple_expr value_expr simple_expr construction ) );
	[GrammarRule("construction")]
	private AstParserRuleReturnScope<object, IToken> construction()
	{
		EnterRule_construction();
		EnterRule("construction", 11);
		TraceIn("construction", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal49 = default(IToken);
		IToken char_literal50 = default(IToken);
		IToken char_literal52 = default(IToken);
		IToken IF53 = default(IToken);
		IToken char_literal54 = default(IToken);
		IToken char_literal56 = default(IToken);
		IToken ELSE58 = default(IToken);
		IToken FOR60 = default(IToken);
		IToken char_literal61 = default(IToken);
		IToken char_literal63 = default(IToken);
		IToken char_literal65 = default(IToken);
		IToken char_literal67 = default(IToken);
		AstParserRuleReturnScope<object, IToken> simple_expr48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> construction51 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr55 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> construction57 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> construction59 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_expr62 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_expr64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple_expr66 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> construction68 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal49_tree = default(object);
		object char_literal50_tree = default(object);
		object char_literal52_tree = default(object);
		object IF53_tree = default(object);
		object char_literal54_tree = default(object);
		object char_literal56_tree = default(object);
		object ELSE58_tree = default(object);
		object FOR60_tree = default(object);
		object char_literal61_tree = default(object);
		object char_literal63_tree = default(object);
		object char_literal65_tree = default(object);
		object char_literal67_tree = default(object);
		RewriteRuleITokenStream stream_36=new RewriteRuleITokenStream(adaptor,"token 36");
		RewriteRuleITokenStream stream_37=new RewriteRuleITokenStream(adaptor,"token 37");
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_40=new RewriteRuleITokenStream(adaptor,"token 40");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleSubtreeStream stream_simple_expr=new RewriteRuleSubtreeStream(adaptor,"rule simple_expr");
		RewriteRuleSubtreeStream stream_value_expr=new RewriteRuleSubtreeStream(adaptor,"rule value_expr");
		RewriteRuleSubtreeStream stream_construction=new RewriteRuleSubtreeStream(adaptor,"rule construction");
		try { DebugEnterRule(GrammarFileName, "construction");
		DebugLocation(140, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:141:2: ( simple_expr ';' !| '{' ( construction )* '}' -> ^( BLOCK ( construction )* ) | IF ^ '(' ! value_expr ')' ! construction ( ELSE ! construction )? | FOR '(' simple_expr ';' value_expr ';' simple_expr ')' construction -> ^( FOR simple_expr value_expr simple_expr construction ) )
			int alt15=4;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case ID:
			case READ:
			case WRITE:
				{
				alt15 = 1;
				}
				break;
			case 40:
				{
				alt15 = 2;
				}
				break;
			case IF:
				{
				alt15 = 3;
				}
				break;
			case FOR:
				{
				alt15 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:141:4: simple_expr ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(141, 4);
				PushFollow(Follow._simple_expr_in_construction812);
				simple_expr48=simple_expr();
				PopFollow();

				adaptor.AddChild(root_0, simple_expr48.Tree);
				DebugLocation(141, 19);
				char_literal49=(IToken)Match(input,39,Follow._39_in_construction814); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:143:4: '{' ( construction )* '}'
				{
				DebugLocation(143, 4);
				char_literal50=(IToken)Match(input,40,Follow._40_in_construction822);  
				stream_40.Add(char_literal50);

				DebugLocation(143, 8);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:143:8: ( construction )*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==FOR||(LA13_1>=ID && LA13_1<=IF)||LA13_1==READ||LA13_1==WRITE||LA13_1==40))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:143:8: construction
						{
						DebugLocation(143, 8);
						PushFollow(Follow._construction_in_construction824);
						construction51=construction();
						PopFollow();

						stream_construction.Add(construction51.Tree);

						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }

				DebugLocation(143, 22);
				char_literal52=(IToken)Match(input,41,Follow._41_in_construction827);  
				stream_41.Add(char_literal52);



				{
				// AST REWRITE
				// elements: construction
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 143:26: -> ^( BLOCK ( construction )* )
				{
					DebugLocation(143, 29);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:143:29: ^( BLOCK ( construction )* )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(143, 31);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, "BLOCK"), root_1);

					DebugLocation(143, 37);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:143:37: ( construction )*
					while ( stream_construction.HasNext )
					{
						DebugLocation(143, 37);
						adaptor.AddChild(root_1, stream_construction.NextTree());

					}
					stream_construction.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:144:4: IF ^ '(' ! value_expr ')' ! construction ( ELSE ! construction )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(144, 6);
				IF53=(IToken)Match(input,IF,Follow._IF_in_construction843); 
				IF53_tree = (object)adaptor.Create(IF53);
				root_0 = (object)adaptor.BecomeRoot(IF53_tree, root_0);
				DebugLocation(144, 11);
				char_literal54=(IToken)Match(input,36,Follow._36_in_construction846); 
				DebugLocation(144, 13);
				PushFollow(Follow._value_expr_in_construction849);
				value_expr55=value_expr();
				PopFollow();

				adaptor.AddChild(root_0, value_expr55.Tree);
				DebugLocation(144, 27);
				char_literal56=(IToken)Match(input,37,Follow._37_in_construction851); 
				DebugLocation(144, 29);
				PushFollow(Follow._construction_in_construction854);
				construction57=construction();
				PopFollow();

				adaptor.AddChild(root_0, construction57.Tree);
				DebugLocation(144, 42);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:144:42: ( ELSE ! construction )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==ELSE))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:144:44: ELSE ! construction
					{
					DebugLocation(144, 48);
					ELSE58=(IToken)Match(input,ELSE,Follow._ELSE_in_construction858); 
					DebugLocation(144, 50);
					PushFollow(Follow._construction_in_construction861);
					construction59=construction();
					PopFollow();

					adaptor.AddChild(root_0, construction59.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(14); }


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:145:4: FOR '(' simple_expr ';' value_expr ';' simple_expr ')' construction
				{
				DebugLocation(145, 4);
				FOR60=(IToken)Match(input,FOR,Follow._FOR_in_construction869);  
				stream_FOR.Add(FOR60);

				DebugLocation(145, 8);
				char_literal61=(IToken)Match(input,36,Follow._36_in_construction871);  
				stream_36.Add(char_literal61);

				DebugLocation(145, 12);
				PushFollow(Follow._simple_expr_in_construction873);
				simple_expr62=simple_expr();
				PopFollow();

				stream_simple_expr.Add(simple_expr62.Tree);
				DebugLocation(145, 24);
				char_literal63=(IToken)Match(input,39,Follow._39_in_construction875);  
				stream_39.Add(char_literal63);

				DebugLocation(145, 28);
				PushFollow(Follow._value_expr_in_construction877);
				value_expr64=value_expr();
				PopFollow();

				stream_value_expr.Add(value_expr64.Tree);
				DebugLocation(145, 39);
				char_literal65=(IToken)Match(input,39,Follow._39_in_construction879);  
				stream_39.Add(char_literal65);

				DebugLocation(145, 43);
				PushFollow(Follow._simple_expr_in_construction881);
				simple_expr66=simple_expr();
				PopFollow();

				stream_simple_expr.Add(simple_expr66.Tree);
				DebugLocation(145, 55);
				char_literal67=(IToken)Match(input,37,Follow._37_in_construction883);  
				stream_37.Add(char_literal67);

				DebugLocation(145, 59);
				PushFollow(Follow._construction_in_construction885);
				construction68=construction();
				PopFollow();

				stream_construction.Add(construction68.Tree);


				{
				// AST REWRITE
				// elements: simple_expr, FOR, value_expr, simple_expr, construction
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 145:72: -> ^( FOR simple_expr value_expr simple_expr construction )
				{
					DebugLocation(145, 75);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:145:75: ^( FOR simple_expr value_expr simple_expr construction )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(145, 77);
					root_1 = (object)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

					DebugLocation(145, 81);
					adaptor.AddChild(root_1, stream_simple_expr.NextTree());
					DebugLocation(145, 93);
					adaptor.AddChild(root_1, stream_value_expr.NextTree());
					DebugLocation(145, 104);
					adaptor.AddChild(root_1, stream_simple_expr.NextTree());
					DebugLocation(145, 116);
					adaptor.AddChild(root_1, stream_construction.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("construction", 11);
			LeaveRule("construction", 11);
			LeaveRule_construction();
		}
		DebugLocation(146, 1);
		} finally { DebugExitRule(GrammarFileName, "construction"); }
		return retval;

	}
	// $ANTLR end "construction"

	partial void EnterRule_result();
	partial void LeaveRule_result();
	// $ANTLR start "result"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:148:1: result : ( construction )* EOF -> ^( PROGRAM ( construction )* ) ;
	[GrammarRule("result")]
	private AstParserRuleReturnScope<object, IToken> result()
	{
		EnterRule_result();
		EnterRule("result", 12);
		TraceIn("result", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF70 = default(IToken);
		AstParserRuleReturnScope<object, IToken> construction69 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF70_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_construction=new RewriteRuleSubtreeStream(adaptor,"rule construction");
		try { DebugEnterRule(GrammarFileName, "result");
		DebugLocation(148, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:149:2: ( ( construction )* EOF -> ^( PROGRAM ( construction )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:149:4: ( construction )* EOF
			{
			DebugLocation(149, 4);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:149:4: ( construction )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==FOR||(LA16_1>=ID && LA16_1<=IF)||LA16_1==READ||LA16_1==WRITE||LA16_1==40))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:149:4: construction
					{
					DebugLocation(149, 4);
					PushFollow(Follow._construction_in_result911);
					construction69=construction();
					PopFollow();

					stream_construction.Add(construction69.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(149, 18);
			EOF70=(IToken)Match(input,EOF,Follow._EOF_in_result914);  
			stream_EOF.Add(EOF70);



			{
			// AST REWRITE
			// elements: construction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 149:22: -> ^( PROGRAM ( construction )* )
			{
				DebugLocation(149, 25);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:149:25: ^( PROGRAM ( construction )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(149, 28);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(149, 36);
				// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:149:36: ( construction )*
				while ( stream_construction.HasNext )
				{
					DebugLocation(149, 36);
					adaptor.AddChild(root_1, stream_construction.NextTree());

				}
				stream_construction.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("result", 12);
			LeaveRule("result", 12);
			LeaveRule_result();
		}
		DebugLocation(150, 1);
		} finally { DebugExitRule(GrammarFileName, "result"); }
		return retval;

	}
	// $ANTLR end "result"

	partial void EnterRule_execute();
	partial void LeaveRule_execute();
	// $ANTLR start "execute"
	// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:152:8: public execute : result ;
	[GrammarRule("execute")]
	public AstParserRuleReturnScope<object, IToken> execute()
	{
		EnterRule_execute();
		EnterRule("execute", 13);
		TraceIn("execute", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> result71 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "execute");
		DebugLocation(152, 1);
		try
		{
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:153:2: ( result )
			DebugEnterAlt(1);
			// C:\\Users\\Alexandr\\Documents\\vsu_compiler\\t_comp\\t_comp\\c.g:153:4: result
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(153, 4);
			PushFollow(Follow._result_in_execute938);
			result71=result();
			PopFollow();

			adaptor.AddChild(root_0, result71.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("execute", 13);
			LeaveRule("execute", 13);
			LeaveRule_execute();
		}
		DebugLocation(154, 1);
		} finally { DebugExitRule(GrammarFileName, "execute"); }
		return retval;

	}
	// $ANTLR end "execute"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _NUMBER_in_primitive_value471 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _STRING_in_primitive_value476 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _LOGIC_in_primitive_value481 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _ID_in_primitive_value486 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _func_call_in_primitive_value491 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _36_in_value_group502 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_add_in_value_group505 = new BitSet(new ulong[]{0x0000002000000000UL});
		public static readonly BitSet _37_in_value_group507 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _primitive_value_in_value_group512 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _value_group_in_value_mult524 = new BitSet(new ulong[]{0x0000000002000202UL});
		public static readonly BitSet _set_in_value_mult528 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_group_in_value_mult539 = new BitSet(new ulong[]{0x0000000002000202UL});
		public static readonly BitSet _value_mult_in_value_add554 = new BitSet(new ulong[]{0x0000000200000012UL});
		public static readonly BitSet _set_in_value_add558 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_mult_in_value_add569 = new BitSet(new ulong[]{0x0000000200000012UL});
		public static readonly BitSet _value_add_in_logic_group585 = new BitSet(new ulong[]{0x000000000490C802UL});
		public static readonly BitSet _set_in_logic_group589 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_add_in_logic_group616 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _logic_group_in_logic_mult631 = new BitSet(new ulong[]{0x0000000000200002UL});
		public static readonly BitSet _LMUL_in_logic_mult635 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _logic_group_in_logic_mult638 = new BitSet(new ulong[]{0x0000000000200002UL});
		public static readonly BitSet _logic_mult_in_logic_add652 = new BitSet(new ulong[]{0x0000000000080002UL});
		public static readonly BitSet _LADD_in_logic_add656 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _logic_mult_in_logic_add659 = new BitSet(new ulong[]{0x0000000000080002UL});
		public static readonly BitSet _logic_add_in_value_expr672 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _ID_in_func_call687 = new BitSet(new ulong[]{0x0000001000000000UL});
		public static readonly BitSet _36_in_func_call689 = new BitSet(new ulong[]{0x0000003088410000UL});
		public static readonly BitSet _value_expr_in_func_call693 = new BitSet(new ulong[]{0x0000006000000000UL});
		public static readonly BitSet _38_in_func_call697 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_expr_in_func_call699 = new BitSet(new ulong[]{0x0000006000000000UL});
		public static readonly BitSet _37_in_func_call706 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _ID_in_simple_expr738 = new BitSet(new ulong[]{0x0000000000000020UL});
		public static readonly BitSet _ASSIGN_in_simple_expr740 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_expr_in_simple_expr743 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _func_call_in_simple_expr749 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _READ_in_simple_expr757 = new BitSet(new ulong[]{0x0000001000000000UL});
		public static readonly BitSet _36_in_simple_expr760 = new BitSet(new ulong[]{0x0000000000010000UL});
		public static readonly BitSet _ID_in_simple_expr763 = new BitSet(new ulong[]{0x0000006000000000UL});
		public static readonly BitSet _38_in_simple_expr767 = new BitSet(new ulong[]{0x0000000000010000UL});
		public static readonly BitSet _ID_in_simple_expr770 = new BitSet(new ulong[]{0x0000006000000000UL});
		public static readonly BitSet _37_in_simple_expr774 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _WRITE_in_simple_expr780 = new BitSet(new ulong[]{0x0000001000000000UL});
		public static readonly BitSet _36_in_simple_expr783 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_expr_in_simple_expr786 = new BitSet(new ulong[]{0x0000006000000000UL});
		public static readonly BitSet _38_in_simple_expr790 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_expr_in_simple_expr793 = new BitSet(new ulong[]{0x0000006000000000UL});
		public static readonly BitSet _37_in_simple_expr797 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _simple_expr_in_construction812 = new BitSet(new ulong[]{0x0000008000000000UL});
		public static readonly BitSet _39_in_construction814 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _40_in_construction822 = new BitSet(new ulong[]{0x0000030420031000UL});
		public static readonly BitSet _construction_in_construction824 = new BitSet(new ulong[]{0x0000030420031000UL});
		public static readonly BitSet _41_in_construction827 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _IF_in_construction843 = new BitSet(new ulong[]{0x0000001000000000UL});
		public static readonly BitSet _36_in_construction846 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_expr_in_construction849 = new BitSet(new ulong[]{0x0000002000000000UL});
		public static readonly BitSet _37_in_construction851 = new BitSet(new ulong[]{0x0000010420031000UL});
		public static readonly BitSet _construction_in_construction854 = new BitSet(new ulong[]{0x0000000000000402UL});
		public static readonly BitSet _ELSE_in_construction858 = new BitSet(new ulong[]{0x0000010420031000UL});
		public static readonly BitSet _construction_in_construction861 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _FOR_in_construction869 = new BitSet(new ulong[]{0x0000001000000000UL});
		public static readonly BitSet _36_in_construction871 = new BitSet(new ulong[]{0x0000000420010000UL});
		public static readonly BitSet _simple_expr_in_construction873 = new BitSet(new ulong[]{0x0000008000000000UL});
		public static readonly BitSet _39_in_construction875 = new BitSet(new ulong[]{0x0000001088410000UL});
		public static readonly BitSet _value_expr_in_construction877 = new BitSet(new ulong[]{0x0000008000000000UL});
		public static readonly BitSet _39_in_construction879 = new BitSet(new ulong[]{0x0000000420010000UL});
		public static readonly BitSet _simple_expr_in_construction881 = new BitSet(new ulong[]{0x0000002000000000UL});
		public static readonly BitSet _37_in_construction883 = new BitSet(new ulong[]{0x0000010420031000UL});
		public static readonly BitSet _construction_in_construction885 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _construction_in_result911 = new BitSet(new ulong[]{0x0000010420031000UL});
		public static readonly BitSet _EOF_in_result914 = new BitSet(new ulong[]{0x0000000000000002UL});
		public static readonly BitSet _result_in_execute938 = new BitSet(new ulong[]{0x0000000000000002UL});
	}
	#endregion Follow sets
}

} // namespace  t_comp 
